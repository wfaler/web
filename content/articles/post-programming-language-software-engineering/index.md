---
title: "Post programming-language software engineering"
date: "2023-07-27"
description: 'Bruce Lee said "Using no way as a way, having no limitation as limitation", and I think this applies to software engineering and programming languages as well.'
summary: 'Bruce Lee said "Using no way as a way, having no limitation as limitation", and I think this applies to software engineering and programming languages as well.'
toc: false 
readTime: true
autonumber: false 
math: true
tags: ["self-hosting"]
showTags: false
---
As a younger software professional, I was very much into programming languages. I spent a good part of the late 2000's and first half of 2010's being a Scala developer, and rabid typed functional programming acolyte.
I still take a lot of my current style from this period, and I certainly see much of the value in strongly typed FP, but I've mellowed down quite a lot from the advocacy, to the point where I'm more inclined to go with whatever language has the best eco-system for the problem domain I am solving for. In Data/AI this is most certainly Python. For DevOps/SRE, it's probably Golang. For webby stuff, it's Javascript/Typescript/Node. For enterprisey backend stuff, it's probably one of the JVM languages (Java, Kotlin, Scala).

..And the list goes on.

Finally, and perhaps most importantly, one of the reasons I lost interest in evangelising languages is that I realised that the language is only a small part of the equation. 
Typing out the code, even testing the code, is only a very small part of the work of delivering software. Most of the hard, error-prone stuff is around fast feedback-loops (or frequently and sadly, the lack thereof), ways of working, actually having the context, understanding of the goal, the problem and the path there.

The tricky part of software is not the building of the software, but rather knowing what to build, the fact that people never know what they need, what they want, or what will resonate with others. It's the soft, goey, human stuff that is hard. Frequently it involves reigning in the hubris of people who think they know _the solution_ (they most likely don't) and saving people from repeating the same mistakes millions have made before, wasting countless billions of dollars in the process.

In that context, your choice of programming language is quite unimportant, because even with the best guardrails built into the language, there is still an infinite amount of ways to shoot yourself in the foot, even after selecting the perfect tools.

The way I view myself these days, is as a polyglot problem-solver who happens to write a fair amount of code, not as a _language X programmer_. Over the last 20+ years, I've been paid to do work in 20 odd programming languages. I've used practically everything on the JVM. Almost all of the popular dynamically typed interpreted languages. A few compile to binary systems languages. Esoteric strongly typed functional languages from academia. You name it, I've probably at least had to touch it for a paycheck.

At this point, I've practically seen the entire spectrum of type-systems and paradigms, perhaps with Prolog & Logic-programming being the glaring omission.

But don't take my lack of advocacy or preaching for a specific language or style as a lack of interest. I am still interested in learning new languages as they gain momentum, and find out what they have to bring. In fact, not being an acolyte of a specific school probably makes me more open-minded to learning than most. I have no preconceived notions of what is superior or inferior, I'm happy to see what's new and what is old.

To use an expression from someone famous for another pursuit I enjoy, experience has taught me to:

  > “Using no way as a way, having no limitation as limitation.” - Bruce Lee
